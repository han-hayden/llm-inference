# Sangfor AICP 大模型推理性能测试工具 — 系统需求文档

> 版本：v2.0 | 日期：2026-02-23

---

## 1. 系统架构

### 1.1 技术栈
| 层次 | 技术选型 | 说明 |
|------|----------|------|
| 前端 | Vue 3 + TypeScript | SPA 应用，深色科技风 UI |
| UI 框架 | Naive UI | 原生深色主题支持，组件丰富 |
| 图表库 | ECharts | 支持动态曲线、分布图、深色主题 |
| 后端 | Python + FastAPI | 异步高性能，参考 llm-inference-forward 代理方案 |
| 数据存储 | 文件系统（CSV + JSON） | 测试数据以文件形式持久化到固定路径 |
| 任务元数据 | SQLite | 仅存储任务列表、配置等轻量元数据 |
| 部署 | Docker + Helm Chart | K8s 集群一键部署 |
| 代理层 | aiohttp | 异步 HTTP 代理转发（与 llm-inference-forward 一致） |
| PDF 生成 | ReportLab + matplotlib | 后端生成带图表的 PDF 报告 |

### 1.2 架构图

```
┌──────────────────────────────────────────────────────────────┐
│                        K8s Cluster                           │
│  ┌────────────────────────────────────────────────────────┐  │
│  │            Performance Test Tool (Pod)                 │  │
│  │                                                        │  │
│  │  ┌─────────┐   ┌──────────┐   ┌───────────────────┐   │  │
│  │  │  Nginx  │──▶│ FastAPI  │──▶│ /data/results/    │   │  │
│  │  │ (前端)   │   │ (后端)    │   │  ├── task_001/    │   │  │
│  │  └─────────┘   └────┬─────┘   │  │  ├── perf.csv  │   │  │
│  │                     │         │  │  ├── perf.json  │   │  │
│  │              ┌──────┴──────┐  │  │  └── qa.csv     │   │  │
│  │              │  代理转发层  │  │  ├── task_002/    │   │  │
│  │              │  (Proxy)    │  │  └── ...           │   │  │
│  │              └──────┬──────┘  └───────────────────┘   │  │
│  │                     │         ┌──────────┐            │  │
│  │                     │         │ SQLite   │            │  │
│  │                     │         │ (元数据)  │            │  │
│  └─────────────────────┼─────────┴──────────┘            │  │
│                        │                                     │
└────────────────────────┼─────────────────────────────────────┘
                         │
                         ▼
              ┌────────────────────┐
              │  目标模型服务       │
              │  (待优化/已优化)    │
              └────────────────────┘
```

---

## 2. 模块设计

### 2.1 模块划分

| 模块 | 职责 | 关键接口 |
|------|------|----------|
| **Auth 认证模块** | 用户名密码登录，JWT Token 管理 | `POST /api/auth/login` |
| **Proxy 代理模块** | 透明转发请求到目标模型服务，旁路采集性能数据 | `ANY /proxy/**` |
| **Config 配置模块** | 管理目标模型服务地址、API 类型、tokenizer 等配置 | `CRUD /api/config` |
| **Collect 采集模块** | 管理采集任务，控制采集条件，写入文件 | `POST /api/collect/start`, `POST /api/collect/stop` |
| **Metrics 指标模块** | 解析文件计算性能指标统计（avg/P50/P90/P99） | `GET /api/metrics/{task_id}` |
| **Dataset 数据集模块** | 管理 QA 对数据集，支持上传/导出 | `CRUD /api/datasets` |
| **Benchmark 压测模块** | 流量回放和并发压测 | `POST /api/benchmark/start` |
| **Compare 对比模块** | 对比两次测试记录，计算提升百分比 | `GET /api/compare` |
| **Report 报告模块** | 生成带图表的 PDF 性能测试报告 | `POST /api/report/generate` |
| **SSH 服务模块** | 提供 SSH/SFTP 远程终端接入，运维管理 | TCP :22（可配置） |
| **FileManager 文件模块** | 管理后台数据文件，提供文件列表和内容读取 | `GET /api/files/**` |
| **Analysis 分析引擎模块** | 性能瓶颈分析 + 优化建议（插件化，当前预留） | `GET /api/analysis/{task_id}` |
| **Dashboard 仪表盘** | 前端可视化，图表渲染 | 前端组件 |

---

## 3. 数据存储设计

### 3.1 存储策略：文件系统 + 轻量 SQLite

采用**文件为主、SQLite 为辅**的存储方案：
- **文件系统**：存储测试详细数据（性能指标、QA 对），保存到后台固定路径
- **SQLite**：仅存储任务元数据（任务列表、配置、用户信息）

### 3.2 文件目录结构

```
/data/results/                              # 固定根路径（可通过配置修改）
├── tasks.db                                # SQLite 元数据库
├── collect_001_20260223_143000/            # 采集任务目录（任务ID_时间戳）
│   ├── performance_data_0.csv              # 性能指标详细数据（每文件最大1000条）
│   ├── performance_data_1.csv              # 自动轮转的第2个文件
│   ├── performance_summary.json            # 统计摘要（avg/P50/P90/P99）
│   ├── qa_pairs_0.csv                      # QA 对数据（请求输入+响应输出）
│   └── qa_pairs.json                       # QA 对 JSON 格式（含完整 messages）
├── benchmark_002_20260224_100000/          # 压测任务目录
│   ├── performance_data_0.csv
│   ├── performance_summary.json
│   └── qa_pairs_0.csv
└── reports/                                # 生成的 PDF 报告
    ├── report_20260224_120000.pdf
    └── ...
```

### 3.3 性能数据 CSV 格式

参考 llm-inference-forward 的 `PerformanceMonitor.export_to_csv` 方法：

| 列名 | 类型 | 说明 |
|------|------|------|
| 序号 | int | 请求序号，从1开始 |
| request_id | string | 请求唯一标识（UUID） |
| model | string | 模型名称 |
| arrival_time | string | 请求到达时间 |
| completion_time | string | 请求完成时间 |
| prompt_tokens | int | 输入 tokens 数量（来自 usage） |
| forward_cal_tokens | int | 代理本地 tokenizer 计算的 tokens 数量 |
| cached_tokens | int | KV Cache 命中的 tokens 数量 |
| completion_tokens | int | 输出 tokens 数量 |
| total_tokens | int | 总 tokens 数量 |
| ttft_ms | float | TTFT 首 token 时延 (ms) |
| tpot_ms | float | TPOT 每 token 输出耗时 (ms) |
| tps | float | Decode 速度 (tokens/s) |
| e2e_latency_ms | float | 端到端时延 (ms) |
| chunk_count | int | SSE chunk 总数 |

### 3.4 QA 对 CSV 格式

| 列名 | 类型 | 说明 |
|------|------|------|
| 序号 | int | 请求序号 |
| request_id | string | 与性能数据表关联 |
| messages | text | 完整的 messages JSON（含多轮对话） |
| response_content | text | 模型完整响应内容 |
| model | string | 模型名称 |

### 3.5 统计摘要 JSON 格式

```json
{
  "task_id": "collect_001",
  "task_name": "基线采集-20260223",
  "total_requests": 500,
  "time_range": {
    "start": "2026-02-23T14:30:00",
    "end": "2026-02-23T15:45:00"
  },
  "summary": {
    "ttft_ms": { "avg": 120.5, "p50": 100, "p90": 200, "p99": 350, "min": 30, "max": 500 },
    "tpot_ms": { "avg": 15.2, "p50": 12, "p90": 25, "p99": 40, "min": 5, "max": 60 },
    "tps": { "avg": 65.8, "p50": 70, "p90": 50, "p99": 30, "min": 15, "max": 120 },
    "e2e_latency_ms": { "avg": 2500, "p50": 2200, "p90": 3500, "p99": 5000, "min": 500, "max": 8000 },
    "prompt_tokens": { "avg": 256, "p50": 200, "p90": 512, "p99": 1024, "min": 10, "max": 2048 },
    "completion_tokens": { "avg": 128, "p50": 100, "p90": 256, "p99": 512, "min": 5, "max": 1024 },
    "cached_tokens": { "avg": 50, "total": 25000 }
  }
}
```

### 3.6 SQLite 元数据表

#### tasks（任务元数据表）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | TEXT PK | 任务ID（如 `collect_001`） |
| name | TEXT | 任务名称 |
| type | TEXT | `collect` / `benchmark` |
| status | TEXT | `pending` / `running` / `completed` / `stopped` |
| config | TEXT(JSON) | 任务配置（采集条件、并发数等） |
| data_dir | TEXT | 数据文件目录路径 |
| record_count | INTEGER | 已记录请求数 |
| created_at | TEXT | 创建时间 |
| completed_at | TEXT | 完成时间 |

#### proxy_config（代理配置表）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER PK | 主键 |
| target_host | TEXT | 目标模型服务地址 |
| target_port | INTEGER | 目标模型服务端口 |
| api_type | TEXT | `openai_compatible` / `custom` |
| custom_tokens_jsonpath | TEXT | 自定义 API 的 tokens 字段 JSON Path |
| is_active | INTEGER | 是否启用 (0/1) |

#### users（用户表）
| 字段 | 类型 | 说明 |
|------|------|------|
| id | INTEGER PK | 主键 |
| username | TEXT | 用户名 |
| password_hash | TEXT | 密码哈希（bcrypt） |

---

## 4. 接口设计

### 4.1 认证
```
POST /api/auth/login
Request:  { "username": "admin", "password": "xxx" }
Response: { "token": "jwt_token", "expires_in": 86400 }
```

### 4.2 代理配置
```
POST /api/config/proxy
Request: {
  "target_host": "10.0.0.1",
  "target_port": 8080,
  "api_type": "openai_compatible",
  "custom_tokens_jsonpath": null
}

GET /api/config/proxy
Response: { "target_host": "10.0.0.1", "target_port": 8080, "api_type": "openai_compatible", "is_active": true }
```

### 4.3 代理转发
```
ANY /proxy/**

说明：
- OpenAI 兼容模式：/proxy/v1/chat/completions 等路径
- 自定义模式：/proxy/custom/** 自定义路径
- 透明转发，代理层仅旁路异步采集数据
- 强制启用 stream=true + stream_options.include_usage=true 以获取指标
- 若原始请求为 stream=false，代理层收集完流式数据后组装为非流式响应返回
```

### 4.4 采集任务
```
POST /api/collect/start
Request: { "name": "基线采集-20260223", "stop_type": "count", "stop_value": 500 }
Response: { "task_id": "collect_001", "data_dir": "/data/results/collect_001_20260223_143000/" }

POST /api/collect/stop
Request: { "task_id": "collect_001" }

GET /api/collect/tasks
Response: [
  {
    "id": "collect_001",
    "name": "基线采集-20260223",
    "status": "completed",
    "record_count": 500,
    "data_dir": "/data/results/collect_001_20260223_143000/",
    "created_at": "2026-02-23T14:30:00",
    "completed_at": "2026-02-23T15:45:00"
  }
]
```

### 4.5 文件管理（前端数据展示核心）
```
GET /api/files/tasks
说明：列出所有任务的数据目录
Response: [
  { "task_id": "collect_001", "dir": "collect_001_20260223_143000", "files": ["performance_data_0.csv", "performance_summary.json", "qa_pairs_0.csv"] }
]

GET /api/files/{task_id}/performance?page=1&size=20
说明：分页读取性能数据 CSV（后端解析文件，返回 JSON）
Response: {
  "total": 500,
  "page": 1,
  "size": 20,
  "items": [ { "序号": 1, "request_id": "...", "ttft_ms": 120.5, ... } ]
}

GET /api/files/{task_id}/qa?page=1&size=20
说明：分页读取 QA 对数据
Response: { "total": 500, "items": [ { "序号": 1, "messages": [...], "response_content": "..." } ] }

GET /api/files/{task_id}/summary
说明：读取统计摘要 JSON
Response: { ... performance_summary.json 内容 ... }
```

### 4.6 指标统计与分布
```
GET /api/metrics/{task_id}/distributions
说明：解析 CSV 文件计算分布数据
Response: {
  "context_length": [ { "range": "0-256", "count": 120 }, { "range": "256-512", "count": 200 }, ... ],
  "response_latency": [ { "range": "0-1000", "count": 80 }, ... ],
  "cache_hit_rate": [ { "range": "0-0.2", "count": 50 }, ... ]
}
```

### 4.7 压测
```
POST /api/benchmark/start
Request: {
  "name": "优化后压测",
  "source_task_id": "collect_001",
  "concurrency": 10,
  "replay_mode": "concurrent",
  "target_host": "10.0.0.2",
  "target_port": 8080,
  "delay_ms": 100,
  "timeout_s": 60
}
Response: { "task_id": "benchmark_002", "data_dir": "/data/results/benchmark_002_20260224_100000/" }

POST /api/benchmark/upload-dataset
说明：上传外部数据集文件
Request: multipart/form-data (file: JSON/CSV)
Response: { "dataset_id": "upload_001", "record_count": 200 }

GET /api/benchmark/{task_id}/progress
Response: { "total": 500, "completed": 230, "status": "running", "elapsed_s": 120 }
```

### 4.8 对比分析
```
GET /api/compare?baseline_id=collect_001&optimized_id=benchmark_002
说明：对比两次测试的文件数据
Response: {
  "ttft_improvement": {
    "baseline_avg": 120.5,
    "optimized_avg": 45.2,
    "reduction_pct": 62.5
  },
  "decode_speed_improvement": {
    "baseline_avg": 65.8,
    "optimized_avg": 112.3,
    "increase_pct": 70.7
  },
  "ttft_series": {
    "baseline": [120, 115, 130, ...],
    "optimized": [45, 42, 50, ...]
  },
  "decode_speed_series": {
    "baseline": [65, 70, 60, ...],
    "optimized": [110, 115, 108, ...]
  }
}
```

### 4.9 PDF 报告生成
```
POST /api/report/generate
Request: {
  "title": "AICP 模型推理优化性能测试报告",
  "remark": "Qwen2.5-7B 推理优化前后对比",
  "baseline_task_id": "collect_001",
  "optimized_task_id": "benchmark_002"
}
Response: {
  "report_id": "report_20260224_120000",
  "file_path": "/data/results/reports/report_20260224_120000.pdf",
  "download_url": "/api/report/download/report_20260224_120000"
}

GET /api/report/download/{report_id}
说明：下载 PDF 报告文件

GET /api/report/list
Response: [
  { "report_id": "report_20260224_120000", "title": "...", "created_at": "...", "file_size": 2048000 }
]
```

---

## 5. 代理转发层设计（参考 llm-inference-forward）

### 5.1 工作原理
```
客户端请求
    │
    ▼
┌─────────────────────────────────────────────┐
│            FastAPI Proxy Layer               │
│                                             │
│  1. 接收请求，记录 arrival_time              │
│  2. 强制设置 stream=true,                   │
│     stream_options.include_usage=true        │
│  3. 通过 aiohttp 转发到目标服务              │
│  4. 逐 chunk 转发 SSE 响应给客户端           │
│     ├─ 记录 first_token_time (TTFT)         │
│     ├─ 累计 chunk_count                     │
│     └─ 提取 usage（最后一个 chunk）          │
│  5. 若原始 stream=false，组装非流式响应返回   │
│  6. 异步写入性能数据到 CSV/JSON 文件          │
└─────────────────────────────────────────────┘
    │
    ▼
目标模型服务
```

### 5.2 指标采集方式（对齐 llm-inference-forward）

| 指标 | 采集方式 | 参考代码 |
|------|----------|----------|
| **TTFT** | `first_token_time - arrival_time`，首个含 content 的 chunk 到达时计时 | `app.py` PerformanceMonitor |
| **TPOT** | `(completion_time - first_token_time) / (chunk_count - 1)` | `app.py` PerformanceMonitor |
| **TPS (decode速度)** | `(chunk_count - 1) / (completion_time - first_token_time)` | `app.py` PerformanceMonitor |
| **E2E 时延** | `completion_time - arrival_time` | `app.py` PerformanceMonitor |
| **prompt_tokens** | 从 SSE 最后一个 chunk 的 `usage.prompt_tokens` 提取 | `app.py` 流式解析 |
| **completion_tokens** | 从 `usage.completion_tokens` 提取 | `app.py` 流式解析 |
| **cached_tokens** | 从 `usage.prompt_tokens_details.cached_tokens` 提取（sglang/vLLM） | `app.py` 流式解析 |
| **本地 tokens 计算** | 使用 HuggingFace tokenizer 本地计算（校验用） | `app.py` TokenCounter |

### 5.3 SSE 流式处理

参考 llm-inference-forward 的 `read_chunks` 方法：

```python
# 关键逻辑：SSE 消息边界检测 + 缓冲
async for chunk in response.content.iter_any():
    combined = remaining + chunk
    while b'\n\n' in combined:
        boundary = combined.find(b'\n\n') + 2
        complete_msg = combined[:boundary]
        remaining = combined[boundary:]
        # 解析 complete_msg，提取指标
        # 转发给客户端
```

### 5.4 API 适配层

| API 类型 | 识别规则 | 指标提取方式 |
|----------|----------|--------------|
| OpenAI 兼容 | 路径匹配 `/v1/chat/completions` 等 | 从 `usage` 字段自动提取所有指标 |
| 自定义 API | 路径匹配 `/custom/**` | 用户配置 JSON Path 指定 tokens 字段位置 |

### 5.5 数据写入策略

- **异步写入**：使用 `asyncio.Queue` 解耦请求处理和数据写入，不阻塞代理转发
- **批量刷盘**：每 10 条记录或每 5 秒批量写入 CSV 文件
- **文件轮转**：单文件超过 1000 条自动创建新文件（`_0.csv`, `_1.csv`, ...）
- **统计摘要**：采集任务完成时，计算并写入 `performance_summary.json`

---

## 6. PDF 报告生成设计

### 6.1 技术方案

使用 **ReportLab** 生成 PDF，**matplotlib** 生成图表图片嵌入 PDF。

### 6.2 报告结构

```
┌─────────────────────────────────┐
│          报告封面                │
│  项目名称 / 测试时间 / 模型信息  │
├─────────────────────────────────┤
│      第一章：数据特征分析        │
│  ┌─────────────────────────┐    │
│  │ 上下文长度分布直方图     │    │
│  └─────────────────────────┘    │
│  ┌─────────────────────────┐    │
│  │ 响应时延分布直方图       │    │
│  └─────────────────────────┘    │
│  ┌─────────────────────────┐    │
│  │ KV Cache 命中分布图      │    │
│  └─────────────────────────┘    │
├─────────────────────────────────┤
│      第二章：基线性能指标        │
│  ┌─────────────────────────┐    │
│  │ TTFT/TPOT/TPS/E2E       │    │
│  │ 统计表格 (avg/P50/P90)  │    │
│  └─────────────────────────┘    │
├─────────────────────────────────┤
│      第三章：优化效果对比        │
│  ┌──────────┬──────────────┐    │
│  │ TTFT下降  │  TPS提升     │    │
│  │  -62.5%  │  +70.7%     │    │
│  └──────────┴──────────────┘    │
│  ┌─────────────────────────┐    │
│  │ TTFT 对比曲线图（图片）  │    │
│  └─────────────────────────┘    │
│  ┌─────────────────────────┐    │
│  │ Decode速度对比曲线（图片）│    │
│  └─────────────────────────┘    │
├─────────────────────────────────┤
│      第四章：详细数据表格        │
│  分页展示每次请求的性能数据      │
└─────────────────────────────────┘
```

### 6.3 图表生成

后端使用 matplotlib 生成图表，保存为临时 PNG 文件后嵌入 PDF：

| 图表 | 类型 | 数据来源 |
|------|------|----------|
| 上下文长度分布 | 直方图 (histogram) | CSV 的 prompt_tokens 列 |
| 响应时延分布 | 直方图 (histogram) | CSV 的 e2e_latency_ms 列 |
| Cache 命中分布 | 饼图/直方图 | CSV 的 cached_tokens 列 |
| TTFT 对比曲线 | 折线图 (双线) | 两次测试的 ttft_ms 序列 |
| Decode 速度对比曲线 | 折线图 (双线) | 两次测试的 tps 序列 |
| 性能指标统计 | 表格 | performance_summary.json |

---

## 7. 前端页面设计

### 7.1 页面结构
```
├── 登录页
├── 主框架（侧边栏导航 + 内容区）
│   ├── 仪表盘首页（概览 + 最近测试记录列表）
│   ├── 代理配置页
│   │   ├── 目标服务配置（IP + 端口）
│   │   ├── API 类型选择（OpenAI 兼容 / 自定义）
│   │   └── 自定义 API tokens JSON Path 配置
│   ├── 测试记录页（★ 核心页面）
│   │   ├── 所有测试记录列表（采集任务 + 压测任务）
│   │   ├── 任务状态（进行中/已完成/已停止）
│   │   ├── 点击进入 → 测试详情页
│   │   │   ├── 性能数据表格（分页、排序、搜索，解析后台 CSV 文件）
│   │   │   ├── QA 对表格（可展开查看请求/响应详情）
│   │   │   ├── 数据特征分布图表
│   │   │   └── 性能指标汇总卡片
│   │   └── 支持对比选择（勾选两条记录 → 进入对比页）
│   ├── 采集管理页
│   │   ├── 创建/启动/停止采集任务
│   │   └── 采集进度实时展示
│   ├── 压测管理页
│   │   ├── 创建压测任务（选择数据集、并发数、delay、timeout）
│   │   ├── 上传外部数据集
│   │   └── 压测进度实时展示
│   ├── 对比分析页
│   │   ├── 选择两次测试记录
│   │   ├── 关键指标提升卡片（TTFT下降%、TPS提升%）
│   │   └── 对比曲线图（TTFT对比、Decode速度对比）
│   └── 报告管理页
│       ├── 生成 PDF 报告（选择任务、输入标题和备注）
│       ├── 历史报告列表
│       └── 下载/预览报告
```

### 7.2 前端数据加载流程

```
前端页面
    │
    ├── 1. GET /api/files/tasks          → 获取所有任务列表
    ├── 2. GET /api/files/{id}/summary   → 获取统计摘要
    ├── 3. GET /api/files/{id}/performance?page=1&size=20
    │                                     → 分页获取性能数据（后端解析CSV返回JSON）
    ├── 4. GET /api/files/{id}/qa?page=1&size=20
    │                                     → 分页获取QA对数据
    └── 5. GET /api/metrics/{id}/distributions
                                          → 获取分布数据用于图表渲染
```

### 7.3 UI 风格要求
- **色彩**：主背景 `#0a0e1a`，卡片背景 `rgba(255,255,255,0.05)`，强调色渐变 `#00f0ff → #7c3aed`
- **毛玻璃**：卡片 `backdrop-filter: blur(12px)`，边框 `1px solid rgba(255,255,255,0.1)`
- **发光效果**：关键指标数值带 `text-shadow` 发光，边框带 `box-shadow` 微光
- **图表**：ECharts 深色主题，曲线带渐变填充，动画过渡 300ms
- **字体**：`Inter` / `JetBrains Mono`（数据），非衬线字体优先
- **图标**：线性发光风格图标（推荐 Phosphor Icons 或 Lucide）

---

## 8. SSH 服务设计

### 8.1 方案
容器内运行 **OpenSSH Server**，与 FastAPI 后端并行启动。

### 8.2 容器内进程管理
使用 `supervisord` 统一管理多个进程：

```
supervisord
├── nginx          (前端静态文件)
├── uvicorn        (FastAPI 后端)
└── sshd           (OpenSSH Server)
```

### 8.3 SSH 配置
```
# /etc/ssh/sshd_config (关键项)
Port 22                          # 可通过环境变量覆盖
PermitRootLogin no               # 禁止 root 登录
PasswordAuthentication yes       # 密码认证
AllowUsers admin                 # 仅允许 admin 用户
Subsystem sftp /usr/lib/openssh/sftp-server   # 启用 SFTP
```

### 8.4 用户与权限
- 容器构建时创建 `admin` 系统用户，HOME 目录设为 `/home/admin`
- 密码通过环境变量 `SSH_PASSWORD` 注入（Helm values 配置）
- `/data/results/` 目录对 admin 用户开放读写权限
- 日志目录 `/var/log/app/` 开放只读权限

### 8.5 SSH 登录后可用操作
| 操作 | 说明 |
|------|------|
| 查看数据文件 | `ls /data/results/` |
| 查看服务日志 | `tail -f /var/log/app/uvicorn.log` |
| 查看进程状态 | `supervisorctl status` |
| SCP 上传数据集 | `scp dataset.json admin@host:/data/results/` |
| SFTP 下载报告 | `sftp admin@host` → `get /data/results/reports/*.pdf` |

---

## 9. 性能分析引擎设计（插件化扩展预留）

### 9.1 设计目标

当前版本预留分析引擎的接口和扩展点，后续集成具体分析能力时**无需修改核心代码**，仅需实现插件接口并注册即可。

### 9.2 插件化架构

```
┌─────────────────────────────────────────────────┐
│                FastAPI 后端                       │
│                                                 │
│  ┌───────────────────────────────────────────┐  │
│  │          AnalysisEngineManager            │  │
│  │  (引擎注册中心，管理所有已注册的分析插件)    │  │
│  └─────────┬────────────┬───────────┬────────┘  │
│            │            │           │            │
│  ┌─────────▼──┐ ┌───────▼────┐ ┌───▼─────────┐  │
│  │ 内置规则   │ │ 外部API    │ │ LLM智能     │  │
│  │ 引擎(预留) │ │ 引擎(预留) │ │ 引擎(预留)  │  │
│  │            │ │            │ │             │  │
│  │ 基于阈值   │ │ 对接外部   │ │ 调用大模型  │  │
│  │ 规则匹配   │ │ 分析服务   │ │ 生成建议    │  │
│  └────────────┘ └────────────┘ └─────────────┘  │
│       ▲                ▲              ▲          │
│       └────────────────┴──────────────┘          │
│            均实现 AnalysisEngine 接口             │
└─────────────────────────────────────────────────┘
```

### 9.3 抽象接口定义

```python
# app/analysis/base.py

from abc import ABC, abstractmethod
from typing import List, Optional
from pydantic import BaseModel

class Suggestion(BaseModel):
    """单条优化建议"""
    category: str           # 瓶颈类别: "prefill" | "decode" | "cache" | "latency_tail" | "general"
    severity: str           # 严重程度: "critical" | "warning" | "info"
    title: str              # 建议标题，如 "Prefill 阶段耗时过高"
    description: str        # 详细描述
    recommendation: str     # 具体优化建议
    metrics_evidence: dict  # 支撑数据，如 {"avg_ttft": 350, "p99_ttft": 1200, "threshold": 200}

class AnalysisResult(BaseModel):
    """分析结果"""
    engine_name: str
    engine_version: str
    task_id: str
    suggestions: List[Suggestion]
    summary: str            # 总体分析摘要
    raw_data: Optional[dict] = None  # 引擎原始输出（调试用）

class AnalysisEngine(ABC):
    """分析引擎抽象基类 —— 所有引擎插件必须实现此接口"""

    @abstractmethod
    def name(self) -> str:
        """引擎名称"""
        ...

    @abstractmethod
    def version(self) -> str:
        """引擎版本"""
        ...

    @abstractmethod
    async def analyze(self, task_id: str, summary: dict, records: list) -> AnalysisResult:
        """
        执行分析
        :param task_id: 任务ID
        :param summary: performance_summary.json 的内容
        :param records: performance_data CSV 解析后的记录列表
        :return: 分析结果
        """
        ...
```

### 9.4 引擎注册机制

```python
# app/analysis/manager.py

class AnalysisEngineManager:
    """分析引擎管理器"""

    def __init__(self):
        self._engines: dict[str, AnalysisEngine] = {}

    def register(self, engine: AnalysisEngine):
        """注册一个分析引擎插件"""
        self._engines[engine.name()] = engine

    def unregister(self, name: str):
        """注销引擎"""
        self._engines.pop(name, None)

    def list_engines(self) -> list[str]:
        """列出已注册引擎"""
        return list(self._engines.keys())

    async def analyze(self, task_id: str, summary: dict, records: list,
                      engine_name: str = None) -> list[AnalysisResult]:
        """
        执行分析，可指定引擎或运行所有已注册引擎
        """
        targets = [self._engines[engine_name]] if engine_name else self._engines.values()
        results = []
        for engine in targets:
            result = await engine.analyze(task_id, summary, records)
            results.append(result)
        return results

# 全局单例
engine_manager = AnalysisEngineManager()
```

### 9.5 预留 API

```
GET /api/analysis/engines
说明：列出已注册的分析引擎
Response: { "engines": [] }                    # 当前版本返回空列表

GET /api/analysis/{task_id}/suggestions?engine=<name>
说明：获取指定任务的优化建议
Response: {
  "task_id": "collect_001",
  "results": [],                               # 当前版本返回空
  "message": "暂无可用的分析引擎，该功能即将推出"
}

POST /api/analysis/{task_id}/run
说明：手动触发分析（后续使用）
Request: { "engine": "rule_based" }
Response: { "status": "no_engine_available" }   # 当前版本
```

### 9.6 前端预留

- 测试详情页底部增加 **"性能优化建议"** 面板
  - 当前显示空状态卡片："分析引擎即将推出，敬请期待"
  - 预留建议列表渲染组件（按 severity 分级展示，带图标）
- 对比分析页底部预留 **"综合优化建议"** 区域
- PDF 报告中 **不展示** 性能优化建议（优化建议仅在前端页面展示）

### 9.7 后续扩展示例

后续集成分析引擎时，仅需：

```python
# 示例：基于规则的分析引擎
class RuleBasedEngine(AnalysisEngine):
    def name(self) -> str:
        return "rule_based"

    def version(self) -> str:
        return "1.0.0"

    async def analyze(self, task_id, summary, records) -> AnalysisResult:
        suggestions = []

        # 规则1：TTFT P99 超过阈值
        if summary["ttft_ms"]["p99"] > 500:
            suggestions.append(Suggestion(
                category="prefill",
                severity="critical",
                title="Prefill 阶段 P99 延迟过高",
                description=f"TTFT P99={summary['ttft_ms']['p99']}ms，远超 500ms 阈值",
                recommendation="建议启用 Prefix Caching 或减少系统 Prompt 长度",
                metrics_evidence={"p99_ttft": summary["ttft_ms"]["p99"], "threshold": 500}
            ))

        # 规则2：KV Cache 命中率过低 ...
        # 规则3：decode 长尾 ...

        return AnalysisResult(
            engine_name=self.name(),
            engine_version=self.version(),
            task_id=task_id,
            suggestions=suggestions,
            summary=f"发现 {len(suggestions)} 个潜在性能问题"
        )

# 注册到管理器 — 仅需一行代码
engine_manager.register(RuleBasedEngine())
```

---

## 10. 部署方案

### 10.1 容器化
```dockerfile
FROM python:3.11-slim

# 安装系统依赖
RUN apt-get update && apt-get install -y nginx openssh-server supervisor

# 安装 Python 依赖：FastAPI, aiohttp, reportlab, matplotlib, pandas

# 创建 admin 用户（SSH 登录用）
RUN useradd -m -s /bin/bash admin

# 配置 supervisord 管理 nginx + uvicorn + sshd
COPY supervisord.conf /etc/supervisor/conf.d/

# 数据目录挂载点
VOLUME ["/data/results"]

EXPOSE 8080 8081 22
```

### 10.2 Helm Chart 结构
```
helm-chart/
├── Chart.yaml
├── values.yaml
├── templates/
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── configmap.yaml
│   ├── pvc.yaml             # 持久化卷声明（数据文件）
│   └── ingress.yaml (可选)
```

### 10.3 关键配置项 (values.yaml)
```yaml
service:
  type: ClusterIP
  port: 8080               # 工具前端端口
  proxyPort: 8081           # 代理转发端口
  sshPort: 22               # SSH 服务端口

storage:
  dataDir: /data/results    # 数据文件存储路径
  pvcSize: 10Gi             # 持久化卷大小
  storageClass: ""          # 存储类（留空使用默认）

config:
  adminUsername: admin
  adminPassword: changeme   # 同时用于前端登录和 SSH 登录
  maxRecordsPerFile: 1000   # 单文件最大记录数
  flushInterval: 5          # 数据刷盘间隔（秒）
  flushBatch: 10            # 数据刷盘批次大小

ssh:
  enabled: true             # 是否启用 SSH 服务
  port: 22                  # SSH 端口
  # 密码复用 config.adminPassword，也可单独配置
  # sshPassword: ""         # 留空则使用 adminPassword

tokenizer:
  enabled: false            # 是否启用本地 tokenizer 校验
  modelPath: ""             # HuggingFace tokenizer 模型路径

resources:
  requests:
    cpu: 500m
    memory: 512Mi
  limits:
    cpu: 2000m
    memory: 2Gi
```

---

## 11. 开发计划（建议）

| 阶段 | 内容 | 优先级 |
|------|------|--------|
| **P0** | 代理转发层（参考 llm-inference-forward，SSE 处理 + 指标采集） | 最高 |
| **P0** | 数据文件存储（CSV + JSON 写入、文件轮转） | 最高 |
| **P0** | 文件管理 API（列表、分页读取、摘要） | 最高 |
| **P0** | 基线采集任务管理（启动/停止/状态） | 最高 |
| **P1** | 前端 — 测试记录页（列表 + 详情表格 + 分布图表） | 高 |
| **P1** | 前端 — 采集管理页 + 代理配置页 | 高 |
| **P1** | QA 对管理 + 流量回放压测 | 高 |
| **P1** | 对比分析（指标卡片 + 曲线图） | 高 |
| **P2** | PDF 报告生成（ReportLab + matplotlib） | 中 |
| **P2** | 登录认证 + Helm Chart 部署 + PVC | 中 |
| **P2** | SSH 服务 + supervisord 进程管理 | 中 |
| **P2** | 外部数据集上传 + 本地 tokenizer 校验 | 中 |
| **P3** | 分析引擎插件接口预留 + 前端占位 UI + 预留 API | 低 |
| **P3+** | （后续）集成规则引擎 / LLM 智能分析引擎 | 后续迭代 |
